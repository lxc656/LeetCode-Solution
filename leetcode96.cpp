/*二叉搜索树有一个特点，就是它中序遍历所得到的序列是有序的
由1~n这n个节点所构建而成的二叉搜索树，对它进行中序遍历输出的结果也必然是1~n
中序遍历时会先遍历二叉搜索树的根节点的左子树，然后是根节点，然后是根节点的右子树
因此输出的结果序列里面，一定是前面一半是左子树的输出序列，随后是根节点，最后是右子树的输出序列
就像下面这样：
|-------------|--k--|-------------|
{左子树的输出序列}根节点{右子树的输出序列}
假设根节点的值是k的话，中序遍历的输出序列是l~r的二叉搜索树有f(l, r)种，
那么根节点为k的时候，就对应着f(1, k-1)*f(k+1, n)种二叉搜索树
并且f(x, y)的值只和(x-y+1)，即相应的中序遍历输出序列的长度有关
k可以取1~n
其实是有公式的，由1～n这n个节点所构成的二叉搜索树的数量是catalan number，即：
  n    /
C     /n+1（n+1分之C 2n n这个排列组合）
  2n /
catalan number也是很多问题的通解，在acwing的算法基础课的数学专题里面有更详细的介绍
leetcode 95题也和这个有关*/
class Solution {
public:
    int numTrees(int n) {
        vector<int> ways(n+1);
        ways[0] = 1;
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=i; j++) {
                ways[i]+=ways[j-1]*ways[i-j];
            }
        }
        return ways[n];
    }
};