/*用递归来做，f(k)表示nums1和nums2这两个数组合并并且排好序后的第k大的数
想求f(k)的值，可以使用递归的方法拆分成子问题来解决:
nums1|--------|---------|
             /|\ 
              | 
             k/2

nums2|--------|---------|
             /|\ 
              | 
             k/2 

（以下假设nums[k]是nums数组的第k个元素）
如果nums1[k/2] < nums2[k/2]，那么在nums1和nums2所合成的有序数组中，小于nums1[k/2]的
元素的个数就是小于（k-1）的（在nums1里有（k/2-1）个元素的值小于它，在nums2里有小于（k/2-1）个元素的值
小于它），因此nums1的第1～k/2个数一定不会是答案

如果nums1[k/2] > nums2[k/2]，那么num2的第1～2/k个数也一定不会是答案

如果nums1[k/2] == nums[k/2]，那么nums1[k/2]或者nums2[k/2]就是我们想要的答案

因此每经过这样一波比较，就会有k/2个元素被我们筛出考虑范围，比如说在前面所说的nums1[k/2] < nums2[k/2]
这个情况下，下一步就是考虑如下的两个序列按照顺序合并得到的序列的第(k-k/2)大的元素
nums1         |---------|
             /|\ 
              | 
             k/2

nums2|------------------|

就这样迭代下去，每次迭代完成之后，k的规模都会变成之前的1/2，直至达到边界条件：k=1
k=1时，只需要比较剩下的两个有序数组的开头的元素哪个更小，将更小值返回

因为k不断地除以2，直至变成1，因此时间复杂度是O(logN)级别的
由因为k的初始值是(n+m)/2，所以时间复杂度是O(log((n+m)/2))，也就是O(log(n+m))
*/
